https://www.baeldung.com/java-microbenchmark-harness
http://tutorials.jenkov.com/java-performance/jmh.html
https://github.com/openjdk/jmh


JMH is short for Java Microbenchmark Harness.
JMH is developed by the same people who implement the Java virtual machine
JVM makes many optimizations

@Benchmark

@BenchmarkMode - JMH supports some possible benchmarks: Throughput, AverageTime, SampleTime, and SingleShotTime.

@Fork(1) - how many times the benchmark will be executed

@Warmup(iterations = 10, timeUnit = TimeUnit.NANOSECONDS) - annotation can be used to control the number of warmup iterations.

@Measurement(iterations = 1000, timeUnit = TimeUnit.NANOSECONDS) - this is the measurement itself

batchSize = 10

-----------------------------------------------------------------------------------------------------------------------

Dead Code Elimination
Blackhole

When running microbenchmarks, it's very important to be aware of optimizations

@Benchmark
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@BenchmarkMode(Mode.AverageTime)
public void doNothing() {
}

@Benchmark
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@BenchmarkMode(Mode.AverageTime)
public void objectCreation() {
    new Object();
}

We expect object allocation costs more than doing nothing at all. However, if we run the benchmarks:

Benchmark                 Mode  Cnt  Score   Error  Units
BenchMark.doNothing       avgt   40  0.609 ± 0.006  ns/op
BenchMark.objectCreation  avgt   40  0.613 ± 0.007  ns/op

In order to prevent this optimization, we should somehow trick the compiler and make it think that the code is used by some other component.
One way to achieve this is just to return the created object.

@Benchmark
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@BenchmarkMode(Mode.AverageTime)
public Object pillarsOfCreation() {
    return new Object();
}

Also, we can let the Blackhole consume it.

@Benchmark
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@BenchmarkMode(Mode.AverageTime)
public void blackHole(Blackhole blackhole) {
    blackhole.consume(new Object());
}

Having Blackhole consume the object is a way to convince the JIT compiler to not apply the dead code elimination optimization.